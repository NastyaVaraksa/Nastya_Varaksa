<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
  #sCanvas {
  width: 300px;
  height: 200px;
}

    </style>
</head>
<body>
    <!-- <canvas width="750" height="585" id="game"></canvas> -->
    <canvas id="sCanvas" width="600" height="400" style="border: solid;"></canvas>

 <script>


var c = document.getElementById("sCanvas");
var ctx = sCanvas.getContext("2d");
var cHeight = sCanvas.height;
var cWidth = sCanvas.width;

//Objects

//create paddle object

function Paddle(x, y) {

  this.colour = "red";
  this.xPos = x;
  this.yPos = y;
  this.width = 12;
  this.height = 60;
  this.speed = 3;

}

Paddle.prototype.drawMe = function() {
  ctx.fillStyle = this.colour;
  ctx.fillRect(this.xPos, this.yPos, this.width, this.height);
}; // end paddle object


/***** BEGIN COLLISION DECTECTION FUNCTIONS *****/
// optimized collision of boxes - Does a hit b?
function hit(a, b) {
  
  // Return immediately when the objects aren't touching.
  if (
    a.x2 < b.x || // a.right is before b.left
    b.x2 < a.x || // b.right is before a.left
    a.y2 < b.y || // a.bottom is before b.top
    b.y2 < a.y    // b.bottom is before a.top
  ) {
    return false;
  }

  // The objects are touching. It is a hit or collision.
  return true;
}

// does a hit the top of b?
function hitTop(a, b) {
  return (a.y2 > b.y && a.y < b.y) ? true : false;
}

// does a hit the bottom of b?
function hitBottom(a, b) {
  return (a.y < b.y2 && a.y2 > b.y2) ? true : false;
}

// Creates an obect of x, y, x2, y2 for hit detection.
function hitObj(obj) {

  var h = {x:0, y:0, x2:0, y2:0};
    
  if (obj.radius) {
    h.x = obj.xPos - obj.radius;
    h.x2 = obj.xPos + obj.radius;
    h.y = obj.yPos - obj.radius;
    h.y2 = obj.yPos + obj.radius;
  } else {
    h.x = obj.xPos;
    h.x2 = obj.xPos + obj.width | (obj.radius * 2);
    h.y = obj.yPos;
    h.y2 = obj.yPos + obj.height | (obj.radius * 2);
  }
    
  // draw hit box - uncomment to see hit detection
  /*
  ctx.save();
  ctx.strokeStyle = "#000000";
  ctx.lineWidth = 5;
  ctx.strokeRect(h.x, h.y, h.x2 - h.x, h.y2 - h.y);
  ctx.restore();
  */

  return h;
}
/***** END COLLISION DETECTION FUNCTIONS *****/

//create the sphere object
function Sphere() {

  this.radius = (10);
  this.colour = "blue";
  this.xPos = 25; //Math.random() * cWidth;
  this.yPos = 5; //Math.random() * cHeight;
  this.speedY = 5; //* Math.random();
  this.speedX = 5; //* Math.random();
}

Sphere.prototype.drawMe = function() {
  //method to draw itself
  ctx.beginPath();
  ctx.arc(this.xPos, this.yPos, this.radius, 0, Math.PI * 2, true);
  ctx.fillStyle = this.colour;
  ctx.fill();
};

Sphere.prototype.moveMe = function() {
  //method to move itself

  // save start position. change back to start
  // position when there's a hit so we don't
  // get stuck in an object.
  var pos = {
    x: this.xPos,
    y: this.yPos
  };

  // move
  this.yPos += this.speedY;
  this.xPos += this.speedX;

  //bounce off the bottom wall
  if (this.yPos > cHeight - this.radius) {
    this.yPos = pos.y;
    this.speedY = -this.speedY;


  } //bounce off the top wall
  else if (this.yPos < 0 + this.radius) {
    this.yPos = pos.y;
    this.speedY = -this.speedY;
  }
/*
  //stop ball if hit right side
  if (this.xPos > cWidth) {
    this.speedX = 0;
    this.speedY = 0;

  }
*/
  // Bounce off left and right sides.
  if ((this.xPos+this.radius) >= cWidth || this.xPos <= 0) {
    this.xPos = pos.x;
    this.speedX = -this.speedX;
  }
  
  //bounce off player paddle
  else {
    
    var pad1 = hitObj(player1);
    var pad2 = hitObj(player2);
    var ball = hitObj(this);
        
    if (hit(ball, pad2)) {
      // hit player2
      this.xPos = pos.x;
      this.speedX *= -1;
      // if the ball travels down and hits top OR
      // if the ball travels up and hits bottom then bounce back
      if (
        (this.speedY > 0 && hitTop(ball, pad2)) ||    
        (this.speedY < 0 && hitBottom(ball, pad2))
      ) {
        this.yPos = pos.y;
        this.speedY *= -1;
      }
    } else if (hit(ball, pad1)) {
      // hit player1
      this.xPos = pos.x;
      this.speedX *= -1;
      // if the ball travels down and hits top OR
      // if the ball travels up and hits bottom then bounce back
      if (
        (this.speedY > 0 && hitTop(ball, pad1)) ||    
        (this.speedY < 0 && hitBottom(ball, pad1))
      ) {
        this.yPos = pos.y;
        this.speedY *= -1;
      }
    }
  }
};
//end moveMe function


//******************
// create game objects
//******************
var ball = new Sphere();
var player1 = new Paddle(10, 150);
var player2 = new Paddle(580, 150);

//*********************
// Deal with key presses
// **********************

var keysDown = []; //empty array to store which keys are being held down


window.addEventListener("keydown", function(event) {
  keysDown[event.keyCode] = true; //store the code for the key being pressed
});

window.addEventListener("keyup", function(event) {
  delete keysDown[event.keyCode];
});

function checkKeys() {

  if (keysDown[90]) {
    if (player1.yPos > 0) {
      player1.yPos -= player1.speed; //z

    }
  }

  if (keysDown[88]) {
    if (player1.yPos < (cHeight - player1.height)) {
      player1.yPos += player1.speed; //x
    }
  }

  if (keysDown[190]) {
    if (player2.yPos > 0) {
      player2.yPos -= player2.speed; //"."
    }
  }

  if (keysDown[188]) {
    if (player2.yPos < (cHeight - player2.height)) {
      player2.yPos += player2.speed; //","
    }
  }

}

// your 2 new sets of code here for 2 more keys for player 2





//*********************
// Make the score board
// **********************



//*********************
// launch the ball from the centre, left and right, on space bar
// **********************


function render() {
  requestAnimationFrame(render);
  ctx.clearRect(0, 0, cWidth, cHeight);
  ball.drawMe();
  ball.moveMe();
  player1.drawMe();
  player2.drawMe();
  checkKeys();

}

render(); //set the animation and drawing on canvas going





// 2 версия





// // Обращаемся к игровому полю из документа
// const canvas = document.getElementById('game');
// // Делаем поле двухмерным
// const context = canvas.getContext('2d');
// // Размер игровой клетки
// const grid = 15;
// // Высота платформы
// const paddleHeight = grid * 5; // 80
// // Задаём максимальное расстояние, на которое могут двигаться платформы
// const LeftmaxPaddleY = canvas.height - grid - paddleHeight * 2;
// const RightmaxPaddleY = canvas.height - grid - paddleHeight;
// // Скорость платформы
// var paddleSpeed = 6;
// // Скорость мяча
// var ballSpeed = 4;
// // Рекорд
// var record = 0;
// // Набранные очки
// var count = 0;
// // активация секретного уровня
// var secret = false;
// // число отбиваний в секретном режиме
// var secret_count = 0;
// // цвет мяча, на старте — белый
// ballColor = '#ffffff';
// // Узнаём размер хранилища
// var Storage_size = localStorage.length;
// // Если в хранилище что-то есть…
// if (Storage_size > 0) {
//   // Достаём оттуда текущее значение рекорда
//   record = localStorage.getItem('record');
//   // Если там ничего нет —
// } else {
//   // Делаем новую запись и кладём туда ноль — рекорда пока нет
//   localStorage.setItem('record', 0);
// }
// // Описываем левую платформу
// const leftPaddle = {
//   // Ставим её по центру
//   x: grid * 2,
//   y: canvas.height / 2 - paddleHeight / 2,
//   // Ширина — одна клетка
//   width: grid,
//   // Высоту берём из константы
//   height: paddleHeight * 2,
//   // Платформа на старте никуда не движется
//   dy: 0
// };
// // Описываем правую платформу
// const rightPaddle = {
//   // Ставим по центру с правой стороны
//   x: canvas.width - grid * 3,
//   y: canvas.height / 2 - paddleHeight / 2,
//   // Задаём такую же ширину и высоту
//   width: grid,
//   height: paddleHeight,
//   // Правая платформа тоже пока никуда не двигается
//   dy: 0
// };
// // Описываем мячик
// const ball = {
//   // Он появляется в самом центре поля
//   x: canvas.width / 2,
//   y: canvas.height / 2,
//   // квадратный, размером с клетку
//   width: grid,
//   height: grid,
//   // На старте мяч пока не забит, поэтому убираем признак того, что мяч нужно ввести в игру заново
//   resetting: false,
//   // Подаём мяч в правый верхний угол
//   dx: ballSpeed,
//   dy: -ballSpeed
// };
// // Проверка на то, пересекаются два объекта с известными координатами или нет
// // Подробнее тут: https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection
// function collides(obj1, obj2) {
//   return obj1.x < obj2.x + obj2.width &&
//     obj1.x + obj1.width > obj2.x &&
//     obj1.y < obj2.y + obj2.height &&
//     obj1.y + obj1.height > obj2.y;
// }
// // Главный цикл игры
// function loop() {
//   // Очищаем игровое поле
//   requestAnimationFrame(loop);
//   context.clearRect(0, 0, canvas.width, canvas.height);
//   // Если платформы на предыдущем шаге куда-то двигались — пусть продолжают двигаться
//   leftPaddle.y += leftPaddle.dy;
//   rightPaddle.y += rightPaddle.dy;
//   // Если левая платформа пытается вылезти за игровое поле вниз,
//   if (leftPaddle.y < grid) {
//     // то оставляем её на месте
//     leftPaddle.y = grid;
//   }
//   // Проверяем то же самое сверху
//   else if (leftPaddle.y > LeftmaxPaddleY) {
//     leftPaddle.y = LeftmaxPaddleY;
//   }
//   // Если правая платформа пытается вылезти за игровое поле вниз,
//   if (rightPaddle.y < grid) {
//     // то оставляем её на месте
//     rightPaddle.y = grid;
//   }
//   // Проверяем то же самое сверху
//   else if (rightPaddle.y > RightmaxPaddleY) {
//     rightPaddle.y = RightmaxPaddleY;
//   }
//   // Рисуем платформы белым цветом
//   context.fillStyle = 'white';
//   // Каждая платформа — прямоугольник
//   context.fillRect(leftPaddle.x, leftPaddle.y, leftPaddle.width, leftPaddle.height);
//   context.fillRect(rightPaddle.x, rightPaddle.y, rightPaddle.width, rightPaddle.height);
//   // Если мяч на предыдущем шаге куда-то двигался — пусть продолжает двигаться
//   ball.x += ball.dx;
//   ball.y += ball.dy;
//   // пусть платформа движется точно так же, как и мяч
//   leftPaddle.dy = ball.dy;
//   // Если мяч касается стены снизу — меняем направление по оси У на противоположное
//   if (ball.y < grid) {
//     ball.y = grid;
//     ball.dy *= -1;
//   }
//   // Делаем то же самое, если мяч касается стены сверху
//   else if (ball.y + grid > canvas.height - grid) {
//     ball.y = canvas.height - grid * 2;
//     ball.dy *= -1;
//   }
//   // Если мяч улетел за игровое поле влево или вправо — перезапускаем его
//   if ((ball.x < 0 || ball.x > canvas.width) && !ball.resetting) {
//     // Помечаем, что мяч перезапущен, чтобы не зациклиться
//     ball.resetting = true;
//     // Если игрок набрал больше рекорда — записываем это как новый рекорд
//     if (count > record) { record = count };
//     // Обнуляем количество очков у игрока
//     count = 0;
//     // Кладём значение рекорда в хранилище браузера
//     localStorage.setItem('record', record);
//     // Даём секунду на подготовку игрокам
//     setTimeout(() => {
//       // Всё, мяч в игре
//       ball.resetting = false;
//       // Снова запускаем его из центра
//       ball.x = canvas.width / 2;
//       ball.y = canvas.height / 2;
//     }, 1000);
//   }
//   // Если мяч коснулся левой платформы,
//   if (collides(ball, leftPaddle)) {
//     // то отправляем его в обратном направлении
//     ball.dx *= -1;
//     // Увеличиваем координаты мяча на ширину платформы, чтобы не засчитался новый отскок
//     ball.x = leftPaddle.x + leftPaddle.width;
//   }
//   // Проверяем и делаем то же самое для правой платформы
//   else if (collides(ball, rightPaddle)) {
//     ball.dx *= -1;
//     ball.x = rightPaddle.x - ball.width;
//     // считаем отскоки
//     count += 1;
//     // если набралось 10 — активируем секретный уровень
//     if (count >= 10) { secret = true };
//     // а вот и сам секретный уровень
//     if (secret) {
//       // увеличиваем новые отскоки
//       secret_count += 1;
//       // если это число делится на 3 без остатка…
//       if (secret_count % 3 == 0) {
//         // увеличиваем скорость мяча на единицу
//         if (ball.dx > 0) { ball.dx += 1 } else { ball.dx -= 1 };
//         if (ball.dy > 0) { ball.dy += 1 } else { ball.dy -= 1 };
//         // красим мяч случайным образом
//         ballColor = '#' + (Math.random().toString(16) + '000000').substring(2, 8).toUpperCase();
//       }
//     }
//   }
//   // Рисуем мяч нужным цветом
//   context.fillStyle = ballColor;
//   context.fillRect(ball.x, ball.y, ball.width, ball.height);
//   // Рисуем стены
//   context.fillStyle = 'lightgrey';
//   context.fillRect(0, 0, canvas.width, grid);
//   context.fillRect(0, canvas.height - grid, canvas.width, canvas.height);
//   // Рисуем сетку посередине
//   for (let i = grid; i < canvas.height - grid; i += grid * 2) {
//     context.fillRect(canvas.width / 2 - grid / 2, i, grid, grid);
//   }
//   // Отслеживаем нажатия клавиш
//   document.addEventListener('keydown', function (e) {
//     // Если нажата клавиша вверх,
//     if (e.which === 38) {
//       // то двигаем правую платформу вверх
//       rightPaddle.dy = -paddleSpeed;
//     }
//     // Если нажата клавиша вниз,
//     else if (e.which === 40) {
//       // то двигаем правую платформу вниз
//       rightPaddle.dy = paddleSpeed;
//     }
//   });
//   // А теперь следим за тем, когда кто-то отпустит клавишу, чтобы остановить движение платформы
//   document.addEventListener('keyup', function (e) {
//     // Если это стрелка вверх или вниз,
//     if (e.which === 38 || e.which === 40) {
//       // останавливаем правую платформу
//       rightPaddle.dy = 0;
//     }
//   });
//   // Цвет текста
//   context.fillStyle = "#ff0000";
//   // Задаём размер и шрифт
//   context.font = "20pt Courier";
//   // Сначала выводим рекорд
//   context.fillText('Record: ' + record, 150, 550);
//   // Затем — набранные очки
//   context.fillText(count, 450, 550);
// }
// // Запускаем игру
// requestAnimationFrame(loop);	


// model
const grinch = {
    posX: 50,
    posY: 50,
    isRun: false,
    updateView: function() {
        // при любых изменениях модели попадаем сюда
        // представление может быть любым
        // их даже может быть несколько
        webPageView.update(this.posX, this.posY, this.isRun);
    },
    shift: function(x, y) {
        this.posX += (this.isRun ? 30 : 5) * x;
        this.posY += (this.isRun ? 30 : 5) * y;
        this.updateView(); // модель при любых изменениях вызывает обновление представления
    },
    setRun: function(state) {
        this.isRun = state;
        this.updateView(); // модель при любых изменениях вызывает обновление представления
    }
};

// view
const webPageView = {
    runInput: document.getElementById("IRun"),
    grinchBox: document.getElementById("IMan"),
    update: function(x, y, run) {
        this.runInput.checked = run;
        this.grinchBox.style.left = x + "px";
        this.grinchBox.style.top = y + "px";
    }
};

// controller
const controller = {
    addListeners: function() {
        const btnContainer = document.getElementById("buttons");
        const runChecker = document.getElementById("IRun");

        btnContainer.addEventListener("click", function(e) {
            e.preventDefault();

            switch(e.target.id) {
                "btn-left":
                    grinch.shift(-1, 0); // контроллер вызывает только методы модели
                    break;
                "btn-right":
                    grinch.shift(1, 0); // контроллер вызывает только методы модели
                    break;
                "btn-up":
                    grinch.shift(0, -1); // контроллер вызывает только методы модели
                    break;
                "btn-down":
                    grinch.shift(0, 1); // контроллер вызывает только методы модели
                    break;
            }
        });

        runChecker.addEventListener("change", function() {
            grinch.setRun(this.checked); // контроллер вызывает только методы модели
        });
    }
}

controller.addListeners();





 </script>   
</body>
</html>